
  GNU nano 7.2                                                                          firstprog.c                                                                                    #include <stdio.h>
int main()
{
    int i;
    for(i = 0; i < 10; i++)
    {
        // Loop 10 times.
        puts("Hello, world!\n");  // Put the string to the output.
    }
    return 0;
}

jeremy@JEREMYS:~$ ./firstprog
Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

jeremy@JEREMYS:~$


jeremy@JEREMYS:~$ gcc firstprog.c
jeremy@JEREMYS:~$ s -l a.out
s: command not found
jeremy@JEREMYS:~$ ls -l a.out
-rwxr-xr-x 1 jeremy jeremy 15960 Nov 16 20:02 a.out
jeremy@JEREMYS:~$ ./a.out
Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!

Hello, world!


jeremy@JEREMYS:~$ objdump -D a.out | grep -A20 "<main>:"
0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 83 ec 10             sub    $0x10,%rsp
    1155:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
    115c:       eb 13                   jmp    1171 <main+0x28>
    115e:       48 8d 05 9f 0e 00 00    lea    0xe9f(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    1165:       48 89 c7                mov    %rax,%rdi
    1168:       e8 e3 fe ff ff          call   1050 <puts@plt>
    116d:       83 45 fc 01             addl   $0x1,-0x4(%rbp)
    1171:       83 7d fc 09             cmpl   $0x9,-0x4(%rbp)
    1175:       7e e7                   jle    115e <main+0x15>
    1177:       b8 00 00 00 00          mov    $0x0,%eax
    117c:       c9                      leave
    117d:       c3                      ret

Disassembly of section .fini:

0000000000001180 <_fini>:
    1180:       f3 0f 1e fa             endbr64'

jeremy@JEREMYS:~$ objdump -M intel -D a.out | grep -A20 "<main>:"
0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64
    114d:       55                      push   rbp
    114e:       48 89 e5                mov    rbp,rsp
    1151:       48 83 ec 10             sub    rsp,0x10
    1155:       c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
    115c:       eb 13                   jmp    1171 <main+0x28>
    115e:       48 8d 05 9f 0e 00 00    lea    rax,[rip+0xe9f]        # 2004 <_IO_stdin_used+0x4>
    1165:       48 89 c7                mov    rdi,rax
    1168:       e8 e3 fe ff ff          call   1050 <puts@plt>
    116d:       83 45 fc 01             add    DWORD PTR [rbp-0x4],0x1
    1171:       83 7d fc 09             cmp    DWORD PTR [rbp-0x4],0x9
    1175:       7e e7                   jle    115e <main+0x15>
    1177:       b8 00 00 00 00          mov    eax,0x0
    117c:       c9                      leave
    117d:       c3                      ret

Disassembly of section .fini:

0000000000001180 <_fini>:
    1180:       f3 0f 1e fa             endbr64
jeremy@JEREMYS:~$


jeremy@JEREMYS:~$ gdb -q ./a.out
Reading symbols from ./a.out...

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
Downloading separate debug info for /home/jeremy/a.out
(No debugging symbols found in ./a.out)
(gdb) break main
Breakpoint 1 at 0x1151
(gdb) run
Starting program: /home/jeremy/a.out
Downloading separate debug info for system-supplied DSO at 0x7ffff7fc3000
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, 0x0000555555555151 in main ()
(gdb) info registers
rax            0x555555555149      93824992235849
rbx            0x7fffffffe178      140737488347512
rcx            0x555555557dc0      93824992247232
rdx            0x7fffffffe188      140737488347528
rsi            0x7fffffffe178      140737488347512
rdi            0x1                 1
rbp            0x7fffffffe050      0x7fffffffe050
rsp            0x7fffffffe050      0x7fffffffe050
r8             0x0                 0
r9             0x7ffff7fca380      140737353917312
r10            0x7fffffffdd70      140737488346480
r11            0x203               515
r12            0x1                 1
r13            0x0                 0
r14            0x555555557dc0      93824992247232
r15            0x7ffff7ffd000      140737354125312
rip            0x555555555151      0x555555555151 <main+8>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
k0             0x40000             262144
k1             0x22001021          570429473
k2             0x0                 0
k3             0x0                 0
k4             0x0                 0
k5             0x0                 0
k6             0x0                 0
k7             0x0                 0
fs_base        0x7ffff7da3740      140737351661376
gs_base        0x0                 0
(gdb)


jeremy@JEREMYS:~$ set dis intel
jeremy@JEREMYS:~$ echo "set dis intel" > ~/.gdbinit
jeremy@JEREMYS:~$ echo "set dis intel" > ~/.gdbinit




jeremy@JEREMYS:~$ gdb -q ./a.out
(gdb) list
(gdb) list
1       #include <stdio.h>
2       int main()
3       {
4           int i;
5           for(i = 0; i < 10; i++)
6           {
7               // Loop 10 times.
8               puts("Hello, world!\n");  // Put the string to the output.
9           }
10          return 0;
(gdb)

Dump of assembler code for function main:
   0x0000000000001149 <+0>:     endbr64
   0x000000000000114d <+4>:     push   %rbp
   0x000000000000114e <+5>:     mov    %rsp,%rbp
   0x0000000000001151 <+8>:     sub    $0x10,%rsp
   0x0000000000001155 <+12>:    movl   $0x0,-0x4(%rbp)
   0x000000000000115c <+19>:    jmp    0x1171 <main+40>
   0x000000000000115e <+21>:    lea    0xe9f(%rip),%rax        # 0x2004
   0x0000000000001165 <+28>:    mov    %rax,%rdi
   0x0000000000001168 <+31>:    call   0x1050 <puts@plt>
   0x000000000000116d <+36>:    addl   $0x1,-0x4(%rbp)
   0x0000000000001171 <+40>:    cmpl   $0x9,-0x4(%rbp)
   0x0000000000001175 <+44>:    jle    0x115e <main+21>
   0x0000000000001177 <+46>:    mov    $0x0,%eax
   0x000000000000117c <+51>:    leave
   0x000000000000117d <+52>:    ret
End of assembler dump.
(gdb)



End of assembler dump.
(gdb) i r eip
The program has no registers now.
(gdb) break main
Breakpoint 1 at 0x1155: file firstprog.c, line 5.
(gdb) run
Starting program: /home/jeremy/a.out

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at firstprog.c:5
5           for(i = 0; i < 10; i++)
(gdb)




(gdb) info register eip
Invalid register `eip'
(gdb) info register rip
x/2x $rip
rip            0x555555555155      0x555555555155 <main+12>
Invalid register `x/2x'
(gdb) i r rip
rip            0x555555555155      0x555555555155 <main+12>
(gdb) x/o 0x8048384
0x8048384:      Cannot access memory at address 0x8048384
(gdb) x/x $eip
Value can't be converted to integer.
(gdb) x/i $rip
=> 0x555555555155 <main+12>:    movl   $0x0,-0x4(%rbp)
(gdb) x/10i $rip
=> 0x555555555155 <main+12>:    movl   $0x0,-0x4(%rbp)
   0x55555555515c <main+19>:    jmp    0x555555555171 <main+40>
   0x55555555515e <main+21>:    lea    0xe9f(%rip),%rax        # 0x555555556004
   0x555555555165 <main+28>:    mov    %rax,%rdi
   0x555555555168 <main+31>:    call   0x555555555050 <puts@plt>
   0x55555555516d <main+36>:    addl   $0x1,-0x4(%rbp)
   0x555555555171 <main+40>:    cmpl   $0x9,-0x4(%rbp)
   0x555555555175 <main+44>:    jle    0x55555555515e <main+21>
   0x555555555177 <main+46>:    mov    $0x0,%eax



199*(256^3) + 69*(256^2) + 252*(256^1) + 0*(256^0)
3343252480
0*(256^3) + 252*(256^2) + 69*(256^1) + 199*(256^0)
16532935
quit
jeremy@JEREMYS:~$



jeremy@JEREMYS:~$ gdb -q ./a.out
/home/jeremy/.gdbinit:1: Error in sourced command file:
Ambiguous set command "dis intel": disable-randomization, disassemble-next-line, disassembler-options, disassembly-flavor...
Reading symbols from ./a.out...
(gdb) Quit
(gdb) break main
Breakpoint 1 at 0x1155: file firstprog.c, line 5.
(gdb) run
Starting program: /home/jeremy/a.out

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
Downloading separate debug info for system-supplied DSO at 0x7ffff7fc3000
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at firstprog.c:5
5           for(i = 0; i < 10; i++)
(gdb) i r $rip
rip            0x555555555155      0x555555555155 <main+12>
(gdb) x/i $rip
=> 0x555555555155 <main+12>:    movl   $0x0,-0x4(%rbp)
(gdb) x/3i $rip
=> 0x555555555155 <main+12>:    movl   $0x0,-0x4(%rbp)
   0x55555555515c <main+19>:    jmp    0x555555555171 <main+40>
   0x55555555515e <main+21>:    lea    0xe9f(%rip),%rax        # 0x555555556004
(gdb) x/7xb $rip
0x555555555155 <main+12>:       0xc7    0x45    0xfc    0x00    0x00    0x00    0x00
(gdb) x/i $rip
=> 0x555555555155 <main+12>:    movl   $0x0,-0x4(%rbp)
(gdb)


(gdb) nexti
5           for(i = 0; i < 10; i++)
(gdb) x/4xb $1
History has not yet reached $1.
(gdb) x/dw $1
History has not yet reached $1.
(gdb) x/i $rip
=> 0x55555555515c <main+19>:    jmp    0x555555555171 <main+40>
(gdb) x/10i $eip
Value can't be converted to integer.
(gdb) x/10i $rip
=> 0x55555555515c <main+19>:    jmp    0x555555555171 <main+40>
   0x55555555515e <main+21>:    lea    0xe9f(%rip),%rax        # 0x555555556004
   0x555555555165 <main+28>:    mov    %rax,%rdi
   0x555555555168 <main+31>:    call   0x555555555050 <puts@plt>
   0x55555555516d <main+36>:    addl   $0x1,-0x4(%rbp)
   0x555555555171 <main+40>:    cmpl   $0x9,-0x4(%rbp)
   0x555555555175 <main+44>:    jle    0x55555555515e <main+21>
   0x555555555177 <main+46>:    mov    $0x0,%eax
   0x55555555517c <main+51>:    leave
   0x55555555517d <main+52>:    ret
(gdb)


(gdb) x/i $rip
=> 0x55555555515c <main+19>:    jmp    0x555555555171 <main+40>
(gdb) x/10i $eip
Value can't be converted to integer.
(gdb) x/10i $rip
=> 0x55555555515c <main+19>:    jmp    0x555555555171 <main+40>
   0x55555555515e <main+21>:    lea    0xe9f(%rip),%rax        # 0x555555556004
   0x555555555165 <main+28>:    mov    %rax,%rdi
   0x555555555168 <main+31>:    call   0x555555555050 <puts@plt>
   0x55555555516d <main+36>:    addl   $0x1,-0x4(%rbp)
   0x555555555171 <main+40>:    cmpl   $0x9,-0x4(%rbp)
   0x555555555175 <main+44>:    jle    0x55555555515e <main+21>
   0x555555555177 <main+46>:    mov    $0x0,%eax
   0x55555555517c <main+51>:    leave
   0x55555555517d <main+52>:    ret
(gdb) x/6cb 0x8048484
0x8048484:      Cannot access memory at address 0x8048484
(gdb) x/s 0x8048484\
Quit
(gdb) x/s 0x8048484
Invalid number "0x8048484x".
(gdb) nexti
0x0000555555555171      5           for(i = 0; i < 10; i++)
(gdb) i r rip
rip            0x555555555171      0x555555555171 <main+40>
(gdb) x/2i $rip
=> 0x555555555171 <main+40>:    cmpl   $0x9,-0x4(%rbp)
   0x555555555175 <main+44>:    jle    0x55555555515e <main+21>
(gdb) i r esp
esp            0xffffe040          -8128
(gdb) x/2xw 0x555555555171
0x555555555171 <main+40>:       0x09fc7d83      0x00b8e77e
(gdb) x/2xw 0x555555555175
0x555555555175 <main+44>:       0x00b8e77e      0xc9000000
(gdb) x/6cb 0x555555555171
0x555555555171 <main+40>:       -125 '\203'     125 '}' -4 '\374'       9 '\t'  126 '~' -25 '\347'
(gdb) x/s 0x555555555171
0x555555555171:       "Hello, world!\n"

(gdb) x/2i $eip
0x8048393 <main+31>: mov DWORD PTR [esp],0x8048484
0x804839a <main+38>: call 0x80482a0 <printf@plt>
(gdb) x/xw $esp
0x555555555171: 0xb8000ce0
(gdb) nexti
0x555555555171 8 printf("Hello, world!\n");
(gdb) x/xw $esp
0xbffff800: 0x555555555171
(gdb)

(gdb) disass main
Dump of assembler code for function main:
   0x0000555555555149 <+0>:     endbr64
   0x000055555555514d <+4>:     push   %rbp
   0x000055555555514e <+5>:     mov    %rsp,%rbp
   0x0000555555555151 <+8>:     sub    $0x10,%rsp
   0x0000555555555155 <+12>:    movl   $0x0,-0x4(%rbp)
   0x000055555555515c <+19>:    jmp    0x555555555171 <main+40>
   0x000055555555515e <+21>:    lea    0xe9f(%rip),%rax        # 0x555555556004
   0x0000555555555165 <+28>:    mov    %rax,%rdi
   0x0000555555555168 <+31>:    call   0x555555555050 <puts@plt>
   0x000055555555516d <+36>:    addl   $0x1,-0x4(%rbp)
=> 0x0000555555555171 <+40>:    cmpl   $0x9,-0x4(%rbp)
   0x0000555555555175 <+44>:    jle    0x55555555515e <main+21>
   0x0000555555555177 <+46>:    mov    $0x0,%eax
   0x000055555555517c <+51>:    leave
   0x000055555555517d <+52>:    ret
End of assembler dum


Nano char_array.c
  GNU nano 7.2                                                                          char_array.c                                                                                   #include <stdio.h>

int main()
{
    char str_a[20];
    str_a[0] = 'H';
    str_a[1] = 'e';
    str_a[2] = 'l';
    str_a[3] = 'l';
    str_a[4] = 'o';
    str_a[5] = ',';
    str_a[6] = ' ';
    str_a[7] = 'w';
    str_a[8] = 'o';
    str_a[9] = 'r';
    str_a[10] = 'l';
    str_a[11] = 'd';
    str_a[12] = '!';
    str_a[13] = '\n';
    str_a[14] = 0;  // Asegurarte de que la cadena esté terminada con el carácter nulo

    printf("%s", str_a);  // Usar el especificador de formato %s para imprimir la cadena
}

jeremy@JEREMYS:~$ gcc -o char_array char_array.c
jeremy@JEREMYS:~$ ./char_array
Hello, world!
jeremy@JEREMYS:~$ nano char_array.c

  GNU nano 7.2                                                                         char_array2.c                                                                                   #include <stdio.h>
#include <string.h>

int main() {
    char str_a[20];
    strcpy(str_a, "Hello, world!\n");
    printf("%s", str_a);  // Usar %s para imprimir la cadena
}
jeremy@JEREMYS:~$ gcc -g -o char_array2 char_array2.c
jeremy@JEREMYS:~$ gdb -q ./char_array2
/home/jeremy/.gdbinit:1: Error in sourced command file:
Ambiguous set command "dis intel": disable-randomization, disassemble-next-line, disassembler-options, disassembly-flavor...
Reading symbols from ./char_array2...
(gdb) uit
Undefined command: "uit".  Try "help".
(gdb) quit
jeremy@JEREMYS:~$ nano char_array2.c
jeremy@JEREMYS:~$ gdb -q ./char_array2
/home/jeremy/.gdbinit:1: Error in sourced command file:
Ambiguous set command "dis intel": disable-randomization, disassemble-next-line, disassembler-options, disassembly-flavor...
Reading symbols from ./char_array2...
(gdb) list
1       #include <stdio.h>
2       #include <string.h>
3
4       int main() {
5           char str_a[20];
6           strcpy(str_a, "Hello, world!\n");
7           printf("%s", str_a);  // Usar %s para imprimir la cadena
8       }
(gdb) break 6
Breakpoint 1 at 0x1184: file char_array2.c, line 6.
(gdb) break stcpy
Function "stcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 2 (stcpy) pending.
(gdb) break strcpy
Function "strcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 3 (strcpy) pending.
(gdb) break 8
Breakpoint 4 at 0x11c3: file char_array2.c, line 8.
(gdb)


(gdb) run
Starting program: /home/jeremy/char_array2

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
Downloading separate debug info for system-supplied DSO at 0x7ffff7fc3000
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at char_array2.c:6
6           strcpy(str_a, "Hello, world!\n");
(gdb)

(gdb) continue
Continuing.
Hello, world!

Breakpoint 4, main () at char_array2.c:8
8       }
(gdb) x/5i$rip
=> 0x5555555551c3 <main+90>:    mov    -0x8(%rbp),%rdx
   0x5555555551c7 <main+94>:    sub    %fs:0x28,%rdx
   0x5555555551d0 <main+103>:   je     0x5555555551d7 <main+110>
   0x5555555551d2 <main+105>:   call   0x555555555060 <__stack_chk_fail@plt>
   0x5555555551d7 <main+110>:   leave
(gdb)

Breakpoint 1, main () at char_array2.c:6
6           strcpy(str_a, "Hello, world!\n");
(gdb) i r rip
rip            0x555555555184      0x555555555184 <main+27>
(gdb) i r rip
rip            0x555555555184      0x555555555184 <main+27>
(gdb) x/5i$rip
=> 0x555555555184 <main+27>:    lea    -0x20(%rbp),%rax
   0x555555555188 <main+31>:    movabs $0x77202c6f6c6c6548,%rcx
   0x555555555192 <main+41>:    mov    %rcx,(%rax)
   0x555555555195 <main+44>:    movabs $0xa21646c726f77,%rdx
   0x55555555519f <main+54>:    mov    %rdx,0x7(%rax)
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/jeremy/char_array2
Downloading separate debug info for system-supplied DSO at 0x7ffff7fc3000
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at char_array2.c:6
6           strcpy(str_a, "Hello, world!\n");
(gdb) bt
#0  main () at char_array2.c:6
(gdb) bt
#0  main () at char_array2.c:6
(gdb) cont
Continuing.
Hello, world!

Breakpoint 4, main () at char_array2.c:8
8       }
(gdb) bt
#0  main () at char_array2.c:8
(gdb) cont
Continuing.
[Inferior 1 (process 813) exited normally]
(gdb) bt
No stack.
(gdb)

jeremy@JEREMYS:~$ rm datatype_sizes.c
jeremy@JEREMYS:~$ nano datatype_sizes.c
jeremy@JEREMYS:~$ rm datatype_sizes.c
jeremy@JEREMYS:~$ nano datatype_sizes.c
jeremy@JEREMYS:~$ gcc datatype_sizes.c
jeremy@JEREMYS:~$ ./a.out
El tipo de dato 'int' es                 4 bytes
El tipo de dato 'unsigned int' es        4 bytes
El tipo de dato 'short int' es   2 bytes
El tipo de dato 'long int' es    8 bytes
El tipo de dato 'long long int' es 8 bytes
El tipo de dato 'float' es       4 bytes
El tipo de dato 'char' es                1 bytes
jeremy@JEREMYS:~$
jeremy@JEREMYS:~$ gcc datatype_sizes.c
jeremy@JEREMYS:~$ ./a.out
El tipo de dato 'int' es                 4 bytes
El tipo de dato 'unsigned int' es        4 bytes
El tipo de dato 'short int' es   2 bytes
El tipo de dato 'long int' es    8 bytes
El tipo de dato 'long long int' es 8 bytes
El tipo de dato 'float' es       4 bytes
El tipo de dato 'char' es                1 bytes
jeremy@JEREMYS:~$


nano pointer.c
#include <stdio.h>
#include <string.h>

int main() {
    char str_a[20]; // A 20-element character array
    char *pointer;   // A pointer, meant for a character array
    char *pointer2;  // Another pointer

    strcpy(str_a, "Hello, world!\n"); // Copy "Hello, world!\n" to str_a

    pointer = str_a; // Set the first pointer to the start of the array
    printf("%s", pointer); // Use %s to print a null-terminated string

    pointer2 = pointer + 2; // Set the second pointer 2 bytes further in
    printf("%s", pointer2); // Print from pointer2 onwards

    strcpy(pointer2, "y you guys!\n"); // Copy new string starting at pointer2
    printf("%s", pointer); // Print the modified string from pointer

    return 0;
}


jeremy@JEREMYS:~$ gcc -o pointer pointer.c
jeremy@JEREMYS:~$ ./pointer
Hello, world!
llo, world!
Hey you guys!
jeremy@JEREMYS:~$
jeremy@JEREMYS:~$ gdb -q ./pointer
/home/jeremy/.gdbinit:1: Error in sourced command file:
Ambiguous set command "dis intel": disable-randomization, disassemble-next-line, disassembler-options, disassembly-flavor...
Reading symbols from ./pointer...
(gdb) list
1       #include <stdio.h>
2       #include <string.h>
3
4       int main() {
5           char str_a[20]; // A 20-element character array
6           char *pointer;   // A pointer, meant for a character array
7           char *pointer2;  // Another pointer
8
9           strcpy(str_a, "Hello, world!\n"); // Copy "Hello, world!\n" to str_a
10
(gdb) brake 11
Undefined command: "brake".  Try "help".
(gdb) break 11
Breakpoint 1 at 0x11a3: file pointer.c, line 11.
(gdb) run
Starting program: /home/jeremy/pointer

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
Downloading separate debug info for system-supplied DSO at 0x7ffff7fc3000
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at pointer.c:11
11          pointer = str_a; // Set the first pointer to the start of the array
(gdb) x/xw pointer
0xbffff7e0: 0x6c6c6548
(gdb) x/s pointer
0xbffff7e0: "Hello, world!\n"
(gdb)
jeremy@JEREMYS:~$ nano addressof.c
#include <stdio.h>

int main() {
    int int_var = 5;        // Declaramos la variable int_var e inicializamos con 5
    int *int_ptr;           // Declaramos un puntero a entero

    int_ptr = &int_var;     // Asignamos la dirección de memoria de int_var a int_ptr

    // Imprimir el valor de int_var a través del puntero
    printf("El valor de int_var es: %d\n", int_var);
    printf("El valor de int_var a través del puntero es: %d\n", *int_ptr);
    printf("La dirección de memoria de int_var es: %p\n", (void*)int_ptr);  // Mostrar la dirección de memoria

    return 0;
}

jeremy@JEREMYS:~$ nano addressof.c
jeremy@JEREMYS:~$ gcc -g addressof.c
jeremy@JEREMYS:~$ gdb -q ./a.out
/home/jeremy/.gdbinit:1: Error in sourced command file:
Ambiguous set command "dis intel": disable-randomization, disassemble-next-line, disassembler-options, disassembly-flavor...
Reading symbols from ./a.out...
(gdb) list
1       #include <stdio.h>
2
3       int main() {
4           int int_var = 5;        // Declaramos la variable int_var e inicializamos con 5
5           int *int_ptr;           // Declaramos un puntero a entero
6
7           int_ptr = &int_var;     // Asignamos la dirección de memoria de int_var a int_ptr
8
9           // Imprimir el valor de int_var a través del puntero
10          printf("El valor de int_var es: %d\n", int_var);
(gdb) break 8
Breakpoint 1 at 0x1193: file addressof.c, line 10.
(gdb) run
Starting program: /home/jeremy/a.out

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at addressof.c:10
10          printf("El valor de int_var es: %d\n", int_var);
(gdb) print int_var
$1 = 5
(gdb) print $int_var
$2 = void
(gdb) print int_ptr
$3 = (int *) 0x7fffffffe03c
(gdb) print $int_ptr
$4 = void
(gdb)

nano addressof2.c
#include <stdio.h>

int main() {
    int int_var = 5;
    int *int_ptr;
    int_ptr = &int_var;  // Put the address of int_var into int_ptr.

    // Imprimir la dirección de memoria de int_ptr (puntero)
    printf("int_ptr = %p\n", (void*)int_ptr);

    // Imprimir la dirección de memoria de int_ptr
    printf("&int_ptr = %p\n", (void*)&int_ptr);

    // Imprimir el valor al que apunta int_ptr
    printf("*int_ptr = %d\n\n", *int_ptr);

    // Imprimir la dirección de int_var y su valor
    printf("int_var is located at %p and contains %d\n", (void*)&int_var, int_var);

    // Imprimir la dirección de int_ptr, su valor (dirección de int_var) y el valor al que apunta
    printf("int_ptr is located at %p, contains %p, and points to %d\n\n",
           (void*)&int_ptr, (void*)int_ptr, *int_ptr);

    return 0;
}

jeremy@JEREMYS:~$ ./a.out
int_ptr = 0x7ffdf6a29fac
&int_ptr = 0x7ffdf6a29fb0
*int_ptr = 5

int_var is located at 0x7ffdf6a29fac and contains 5
int_ptr is located at 0x7ffdf6a29fb0, contains 0x7ffdf6a29fac, and points to 5

jeremy@JEREMYS:~$ nano fmt_strings.c
jeremy@JEREMYS:~$ gcc -o fmt_strings fmt_strings.c
jeremy@JEREMYS:~$ ./fmt_strings
[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
[field width on B] 3: '31337', 10: '     31337', '00031337'
[string] sample, Address: 0x7ffcbf05bb9e
variable A is at address: 0x7ffcbf05bb94
jeremy@JEREMYS:~$ nano  input.c 
  GNU nano 7.2                                                  input.c *
#include <stdio.h>
#include <string.h>

int main() {
    char message[50];  // Se aumenta el tamaño del arreglo para manejar "Hello, world!" y más
    int count, i;

    strcpy(message, "Hello, world!");  // Copiar la cadena al arreglo

    // Solicitar la cantidad de repeticiones al usuario
    printf("Repeat how many times? ");
    scanf("%d", &count);

    // Verificar que el número de repeticiones sea positivo
    if (count < 1) {
        printf("Please enter a positive number.\n");
        return 1;  // Salir si la entrada no es válida
    }

    // Imprimir el mensaje repetidamente
    for(i = 0; i < count; i++) {
        printf("%3d - %s\n", i + 1, message);  // Imprimir el índice y el mensaje
    }

    return 0;
}
jeremy@JEREMYS:~$ gcc -o input input.c
jeremy@JEREMYS:~$ ./input
Repeat how many times? 3
  1 - Hello, world!
  2 - Hello, world!
  3 - Hello, world!
jeremy@JEREMYS:~$


jeremy@JEREMYS:~$ gcc typecasting.c
jeremy@JEREMYS:~$ ./a.out
[integers]       a = 13  b = 5
[floats]         c = 2.60        d = 2.60
jeremy@JEREMYS:~$nano pointer_typer.c
#include <stdio.h>

int main() {
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    char *char_pointer;
    int *int_pointer;

    char_pointer = char_array; // Apuntar al inicio de char_array.
    int_pointer = int_array;   // Apuntar al inicio de int_array.

    // Recorrer el array de enteros usando int_pointer.
    for(i = 0; i < 5; i++) {
        printf("[integer pointer] points to %p, which contains the integer %d\n",
               (void *)int_pointer, *int_pointer);
        int_pointer = int_pointer + 1;
    }

    // Recorrer el array de caracteres usando char_pointer.
    for(i = 0; i < 5; i++) {
        printf("[char pointer] points to %p, which contains the char '%c'\n",
               (void *)char_pointer, *char_pointer);
        char_pointer = char_pointer + 1;
    }

    return 0; // Indica que el programa terminó exitosamente.
}


jeremy@JEREMYS:~$ nano pointer_types.c
jeremy@JEREMYS:~$ gcc pointer_types.c
jeremy@JEREMYS:~$ ./a.out
[integer pointer] points to 0x7ffff0eb4c20, which contains the integer 1
[integer pointer] points to 0x7ffff0eb4c24, which contains the integer 2
[integer pointer] points to 0x7ffff0eb4c28, which contains the integer 3
[integer pointer] points to 0x7ffff0eb4c2c, which contains the integer 4
[integer pointer] points to 0x7ffff0eb4c30, which contains the integer 5
[char pointer] points to 0x7ffff0eb4c43, which contains the char 'a'
[char pointer] points to 0x7ffff0eb4c44, which contains the char 'b'
[char pointer] points to 0x7ffff0eb4c45, which contains the char 'c'
[char pointer] points to 0x7ffff0eb4c46, which contains the char 'd'
[char pointer] points to 0x7ffff0eb4c47, which contains the char 'e'
jeremy@JEREMYS:~$ nano pointer_types2.c
#include <stdio.h>

int main() {
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    char *char_pointer;
    int *int_pointer;

    // Apuntar los punteros a los arrays correctos
    char_pointer = char_array; // Apuntar al inicio de char_array.
    int_pointer = int_array;   // Apuntar al inicio de int_array.

    // Recorrer el array de enteros usando int_pointer.
    for (i = 0; i < 5; i++) {
        printf("[integer pointer] points to %p, which contains the integer %d\n",
               (void *)int_pointer, *int_pointer);
        int_pointer = int_pointer + 1;
    }

    // Recorrer el array de caracteres usando char_pointer.
    for (i = 0; i < 5; i++) {
        printf("[char pointer] points to %p, which contains the char '%c'\n",
               (void *)char_pointer, *char_pointer);
        char_pointer = char_pointer + 1;
    }

    return 0; // Indicar que el programa terminó exitosamente.
}


jeremy@JEREMYS:~$ gcc pointer_types2.c
jeremy@JEREMYS:~$ ./a.out
[integer pointer] points to 0x7ffd04624890, which contains the integer 1
[integer pointer] points to 0x7ffd04624894, which contains the integer 2
[integer pointer] points to 0x7ffd04624898, which contains the integer 3
[integer pointer] points to 0x7ffd0462489c, which contains the integer 4
[integer pointer] points to 0x7ffd046248a0, which contains the integer 5
[char pointer] points to 0x7ffd046248b3, which contains the char 'a'
[char pointer] points to 0x7ffd046248b4, which contains the char 'b'
[char pointer] points to 0x7ffd046248b5, which contains the char 'c'
[char pointer] points to 0x7ffd046248b6, which contains the char 'd'
[char pointer] points to 0x7ffd046248b7, which contains the char 'e'

jeremy@JEREMYS:~$ nano pointer_types3.c
#include <stdio.h>
int main() {
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};

    char *char_pointer = char_array; // Apunta al inicio de char_array.
    int *int_pointer = int_array;   // Apunta al inicio de int_array.

    // Iterar correctamente sobre el array de enteros usando int_pointer.
    for (i = 0; i < 5; i++) {
        printf("[integer pointer] points to %p, which contains the integer %d\n",
               (void *)int_pointer, *int_pointer);
        int_pointer++; // Avanza al siguiente entero.
    }

    // Iterar correctamente sobre el array de caracteres usando char_pointer.
    for (i = 0; i < 5; i++) {
        printf("[char pointer] points to %p, which contains the char '%c'\n",
               (void *)char_pointer, *char_pointer);
        char_pointer++; // Avanza al siguiente carácter.
    }

    return 0;
}



jeremy@JEREMYS:~$ gcc pointer_types3.c
jeremy@JEREMYS:~$ ./a.out
[integer pointer] points to 0x7ffc16b55600, which contains the integer 1
[integer pointer] points to 0x7ffc16b55604, which contains the integer 2
[integer pointer] points to 0x7ffc16b55608, which contains the integer 3
[integer pointer] points to 0x7ffc16b5560c, which contains the integer 4
[integer pointer] points to 0x7ffc16b55610, which contains the integer 5
[char pointer] points to 0x7ffc16b55623, which contains the char 'a'
[char pointer] points to 0x7ffc16b55624, which contains the char 'b'
[char pointer] points to 0x7ffc16b55625, which contains the char 'c'
[char pointer] points to 0x7ffc16b55626, which contains the char 'd'
[char pointer] points to 0x7ffc16b55627, which contains the char 'e'
jeremy@JEREMYS:~$


jeremy@JEREMYS:~$ nano pointer_types4.c



jeremy@JEREMYS:~$ gcc pointer_types4.c
jeremy@JEREMYS:~$ ./a.out
[char pointer] points to 0x7ffdd31ffe33, which contains the char 'a'
[char pointer] points to 0x7ffdd31ffe34, which contains the char 'b'
[char pointer] points to 0x7ffdd31ffe35, which contains the char 'c'
[char pointer] points to 0x7ffdd31ffe36, which contains the char 'd'
[char pointer] points to 0x7ffdd31ffe37, which contains the char 'e'
[integer pointer] points to 0x7ffdd31ffe10, which contains the integer 1
[integer pointer] points to 0x7ffdd31ffe14, which contains the integer 2
[integer pointer] points to 0x7ffdd31ffe18, which contains the integer 3
[integer pointer] points to 0x7ffdd31ffe1c, which contains the integer 4
[integer pointer] points to 0x7ffdd31ffe20, which contains the integer 5
jeremy@JEREMYS:~$ nano pointer_types5.c
#include <stdio.h>
#include <stdint.h> // Para usar uintptr_t

int main() {
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    uintptr_t hacky_nonpointer;

    // Iterar sobre el array de caracteres
    hacky_nonpointer = (uintptr_t) char_array; // Convertir puntero a entero sin signo
    for (i = 0; i < 5; i++) {
        printf("[hacky_nonpointer] points to %p, which contains the char '%c'\n",
               (void *) hacky_nonpointer, *((char *) hacky_nonpointer));
        hacky_nonpointer += sizeof(char); // Incrementar por el tamaño de un char
    }

    // Iterar sobre el array de enteros
    hacky_nonpointer = (uintptr_t) int_array; // Convertir puntero a entero sin signo
    for (i = 0; i < 5; i++) {
        printf("[hacky_nonpointer] points to %p, which contains the integer %d\n",
               (void *) hacky_nonpointer, *((int *) hacky_nonpointer));
        hacky_nonpointer += sizeof(int); // Incrementar por el tamaño de un int
    }

    return 0;
}
jeremy@JEREMYS:~$ gcc pointer_types5.c
jeremy@JEREMYS:~$ ./a.out
[hacky_nonpointer] points to 0x7fffa75a3be3, which contains the char 'a'
[hacky_nonpointer] points to 0x7fffa75a3be4, which contains the char 'b'
[hacky_nonpointer] points to 0x7fffa75a3be5, which contains the char 'c'
[hacky_nonpointer] points to 0x7fffa75a3be6, which contains the char 'd'
[hacky_nonpointer] points to 0x7fffa75a3be7, which contains the char 'e'
[hacky_nonpointer] points to 0x7fffa75a3bc0, which contains the integer 1
[hacky_nonpointer] points to 0x7fffa75a3bc4, which contains the integer 2
[hacky_nonpointer] points to 0x7fffa75a3bc8, which contains the integer 3
[hacky_nonpointer] points to 0x7fffa75a3bcc, which contains the integer 4
[hacky_nonpointer] points to 0x7fffa75a3bd0, which contains the integer 5
jeremy@JEREMYS:~$
jeremy@JEREMYS:~$ nano commandline.c
#include <stdio.h>

int main(int arg_count, char *arg_list[]) {
    int i;
    printf("There were %d arguments provided:\n", arg_count);
    
    for(i = 0; i < arg_count; i++) {
        printf("argument #%d\t-\t%s\n", i, arg_list[i]);
    }

    return 0;
}

jeremy@JEREMYS:~$ gcc -o commandline commandline.c
jeremy@JEREMYS:~$ ./commandline
There were 1 arguments provided:
argument #0     -       ./commandline
jeremy@JEREMYS:~$ ./commandline this is a test
There were 5 arguments provided:
argument #0     -       ./commandline
argument #1     -       this
argument #2     -       is
argument #3     -       a
argument #4     -       test
jeremy@JEREMYS:~$
jeremy@JEREMYS:~$ nano convert.c
#include <stdio.h>
#include <stdlib.h>  // Necesaria para exit() y atoi()

void usage(char *program_name) {
    printf("Usage: %s <message> <# of times to repeat>\n", program_name);
    exit(1);  // Termina el programa si los argumentos son incorrectos
}

int main(int argc, char *argv[]) {
    int i, count;

    if (argc < 3) {  // Si hay menos de 3 argumentos,
        usage(argv[0]);  // Muestra el mensaje de uso y termina el programa.
    }

    count = atoi(argv[2]);  // Convierte el segundo argumento (número) a entero.

    // Asegúrate de que el número de repeticiones sea positivo.
    if (count <= 0) {
        printf("Error: El número de repeticiones debe ser mayor que 0.\n");
        return 1;  // Salir con un error
    }

    printf("Repeating %d times..\n", count);

    for (i = 0; i < count; i++) {
        printf("%3d - %s\n", i, argv[1]);  // Imprime el primer argumento
    }

    return 0;
}

jeremy@JEREMYS:~$ gcc convert.c
jeremy@JEREMYS:~$ ./a.out
Usage: ./a.out <message> <# of times to repeat>
jeremy@JEREMYS:~$ ./a.out 'Hello, world!' 3
Repeating 3 times..
  0 - Hello, world!
  1 - Hello, world!
  2 - Hello, world!
jeremy@JEREMYS:~$nano convert2.c
#include <stdio.h>
#include <stdlib.h>  // Necesaria para exit() y atoi()

void usage(char *program_name) {
    printf("Usage: %s <message> <# of times to repeat>\n", program_name);
    exit(1);  // Termina el programa si los argumentos no son suficientes.
}

int main(int argc, char *argv[]) {
    int i, count;

    // Verifica si hay menos de 3 argumentos (nombre del programa + 2 argumentos)
    if (argc < 3) {
        usage(argv[0]);  // Muestra el mensaje de uso y termina el programa.
    }

    // Convierte el segundo argumento (número) a entero
    count = atoi(argv[2]);

    // Asegúrate de que el número de repeticiones sea positivo
    if (count <= 0) {
        printf("Error: El número de repeticiones debe ser mayor que 0.\n");
        return 1;  // Salir con un error
    }

    // Muestra el número de repeticiones
    printf("Repeating %d times..\n", count);

    // Imprime el mensaje el número de veces indicado
    for (i = 0; i < count; i++) {
        printf("%3d - %s\n", i, argv[1]);  // Imprime el primer argumento (mensaje)
    }

    return 0;  // Fin exitoso
}

jeremy@JEREMYS:~$ gcc convert2.c
jeremy@JEREMYS:~$ gdb -q ./a.out
/home/jeremy/.gdbinit:1: Error in sourced command file:
Ambiguous set command "dis intel": disable-randomization, disassemble-next-line, disassembler-options, disassembly-flavor...
Reading symbols from ./a.out...
(gdb) run test
Starting program: /home/jeremy/a.out test

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
Downloading separate debug info for system-supplied DSO at 0x7ffff7fc3000
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Usage: /home/jeremy/a.out <message> <# of times to repeat>
[Inferior 1 (process 1179) exited with code 01]
(gdb) where
No stack.
(gdb) break main
Breakpoint 1 at 0x5555555551f1: file convert2.c, line 13.
(gdb) cont
The program is not being run.
(gdb)
jeremy@JEREMYS:~$ nano scope.c
jeremy@JEREMYS:~$ gcc scope.c
jeremy@JEREMYS:~$ ./a.out
[in main] i = 3
        [in func1] i = 5
                [in func2] i = 7
                        [in func3] i = 11
                [back in func2] i = 7
        [back in func1] i = 5
[back in main] i = 3
jeremy@JEREMYS:~$
jeremy@JEREMYS:~$ nano scope2
#include <stdio.h>

int j = 42; // j is a global variable.

void func3() {
    // Local variables: i and j are local to func3()
    int i = 11; 
    int j = 999; // This j is local to func3 and does not affect the global j.
    
    printf("\t\t\t[in func3] i = %d, j = %d\n", i, j);
}

void func2() {
    int i = 7;
    
    // Prints the local variable i and the global j
    printf("\t\t[in func2] i = %d, j = %d\n", i, j);
    
    // Modifying the global j
    printf("\t\t[in func2] setting j = 1337\n");
    j = 1337; // This modifies the global j
    
    // Call func3, where the local j is 999 (does not affect the global j)
    func3();
    
    // After returning from func3, j is still the global one, modified in func2
    printf("\t\t[back in func2] i = %d, j = %d\n", i, j);
}

void func1() {
    int i = 5;
    
    // Prints the local variable i and the global j
    printf("\t[in func1] i = %d, j = %d\n", i, j);
    
    // Call func2
    func2();
    
    // After returning from func2, the global j was modified to 1337
    printf("\t


jeremy@JEREMYS:~$ nano scope2.c
jeremy@JEREMYS:~$ gcc scope2.c
jeremy@JEREMYS:~$ ./a.out
[in main] i = 3, j = 42
        [in func1] i = 5, j = 42
                [in func2] i = 7, j = 42
                [in func2] setting j = 1337
                        [in func3] i = 11, j = 999
                [back in func2] i = 7, j = 1337
        [back in func1] i = 5, j = 1337
[back in main] i = 3, j = 1337
jeremy@JEREMYS:~$ nano spcoe3.c
jeremy@JEREMYS:~$ gcc scope3.c
jeremy@JEREMYS:~$ ./a.out
[in main] i @ 0x7fff7452a8e4 = 3
[in main] j @ 0x55984b864010 = 42
        [in func1] i @ 0x7fff7452a8c4 = 5
        [in func1] j @ 0x55984b864010 = 42
                [in func2] i @ 0x7fff7452a8a4 = 7
                [in func2] j @ 0x55984b864010 = 42
                [in func2] setting j = 1337
                        [in func3] i @ 0x7fff7452a880 = 11
                        [in func3] j @ 0x7fff7452a884 = 999
                [back in func2] i @ 0x7fff7452a8a4 = 7
                [back in func2] j @ 0x55984b864010 = 1337
        [back in func1] i @ 0x7fff7452a8c4 = 5
        [back in func1] j @ 0x55984b864010 = 1337
[back in main] i @ 0x7fff7452a8e4 = 3
[back in main] j @ 0x55984b864010 = 1337
jeremy@JEREMYS:~$

jeremy@JEREMYS:~$ nano static.c
#include <stdio.h>

void function() { // An example function, with its own context
    int var = 5;             // Local variable (reiniciada en cada llamada)
    static int static_var_function = 5; // Static variable, retains value between calls

    // Imprime los valores de las variables en la función
    printf("\t[in function] var = %d\n", var);
    printf("\t[in function] static_var_function = %d\n", static_var_function);

    var++;                    // Incrementa var (solo en la función, no se guarda entre llamadas)
    static_var_function++;    // Incrementa static_var_function (se guarda entre llamadas)
}

int main() { // The main function, with its own context
    int i;
    static int static_var_main = 1337; // Another static, specific to main() and keeps its value across the program

    for(i = 0; i < 5; i++) { // Loop 5 times
        printf("[in main] static_var_main = %d\n", static_var_main);
        function(); // Call the function
    }

    return 0; // Agregar return 0 para indicar que el programa terminó correctamente
}

jeremy@JEREMYS:~$ ./a.out
[in main] i @ 0x7ffd1a77bec4 = 3
[in main] j @ 0x555f16606010 = 42
        [in func1] i @ 0x7ffd1a77bea4 = 5
        [in func1] j @ 0x555f16606010 = 42
                [in func2] i @ 0x7ffd1a77be84 = 7
                [in func2] j @ 0x555f16606010 = 42
                [in func2] setting j = 1337
                        [in func3] i @ 0x7ffd1a77be60 = 11
                        [in func3] j @ 0x7ffd1a77be64 = 999
                [back in func2] i @ 0x7ffd1a77be84 = 7
                [back in func2] j @ 0x555f16606010 = 1337
        [back in func1] i @ 0x7ffd1a77bea4 = 5
        [back in func1] j @ 0x555f16606010 = 1337
[back in main] i @ 0x7ffd1a77bec4 = 3
[back in main] j @ 0x555f16606010 = 1337
jeremy@JEREMYS:~$





















